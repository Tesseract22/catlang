# Catlang
A statically typed, manual-memory-managed, imperative language mainly to educate myself about compiler construction and optimization.
## Limited Scope
For this purpose and in the spirit of recreational programming, I purposefully overcomplicate and oversimplify some parts of the compiler design, so as to make it easier for to explore:

* Interning of types and other compile time objects,
* And other more or less data-oriented approach
* A platform-independent IR (intermediate representation), which is then translated to platform-dependent assembly,
* With a linear register allocation alogrithms, and simple instruction selection & instruction scheduling


For the same reasons, the executable generated by the current backend also does not depend `libc` and the `c runtime`, so long as the standard library is not used.


Catlang's compiler is currently written in `Zig`, and aims to be self-hosted in the future.
The compiler currrently is able to produce x86-64 GNU assembly.




## Roadmap to v0.1.0

### Compatibility
- [x] Compilation for X86-64 linux/windows
- [ ] Compilation for ARM64 linux/windows
- [x] Foreign procedure call (C ABI)
- [ ] External variable


### Lanauage Features
- [ ] File as Module; importing & exporting modules; compilation of multiple files
- [ ] Minimal standard library for Linux
    - [ ] File sytem
    - [ ] String manupulation
    - [ ] Memory Allocation
    - [ ] Output formating
    
- [ ] Reading command line arguments
- [ ] Enum
- [ ] newtype




## Basic Syntax
```rust
proc main() {
    let x := 10;
    let y := x / 2;
    print(f(5, x) + f(4, y));
}
fn f(i: int, j: int): int {
    ret i * j;
}
```
A more comprehensive syntax can be found in [here](SYNTAX.md)

## Install
`zig build` to build the compiler

`zig-out/bin/lang -c <src> -o <out>` to compile a given `.cat` file.

`zig build compile` to compile all the examples in `lang` folder.


## IR & Codegen Design

Although the design of the backend is purposefully simplified, it is stil arguably the most complicated piece of software I have ever developed.

### CIR Design

#### Design Goals
Catlang uses its own `Intermediate Representation`, called `CIR`. It aims to provide an abstraction layer between asembly code and the AST, minimizing code repetition during the lowering of the AST. It is NOT designed with coupling with optimization passes in mind.

#### Overview
* CIR is per-function. In catlang, each function is lowered to a self-contained list of CIRs.
* CIR is platform independent, it is completely agnostic about targeting ISAs.
* CIR is typed, with the same Type System of catlang. It contains type that needs to be `resolved` depending on the platform, such as `Int`, which is basically `ssize_t`.
* CIr does not have the conceopt of `basic block`, or conforms to `SSA`, as in llvm.
The `codegen` calculates sizes and alignments of types directly.
Its coupling with the type system makes it very difficult to used outside of catlang (this is something thatmay change in the future).

#### Instruction
The basic component of CIR is `Instruction`.
Each `Instruction` is supposed be closely related to a machine instruction common in mainstream CPUs. 
`Instruction`s is ordered in a list, closely resembling the execution order of the final assembly.

Each `Instruciton` produces a `Result Location`, such as `reg`, `stack top`, or `literal`, which is determined during code generation. 
Some `Instruction`s may have operands, which is just a reference to another `Instruction`. They will use the `Result Location` of the operands as neeed. The structure of the CIR gurantee that all the operands of the instruction is generated BEFORE itself.


It might be tempting to create and IR completely agnostic to `Type`, but works only with sizes and offsets.
However, this breaks when we want to follow the C ABI: 
```rust
proc foo(a: Int) {
    ...
}

proc bar(a: [1]Int) {
    ...
}
```
Here, the arguments of `foo` and `bar` have the exact same memory layout, but on some calling convention, the argument of `foo` is passed via register, but the arguement of `bar` is passed via memory.
### Code Generation
After each function is lowered into CIRs, the code generator traversed each of them to produce GNU assembly code, which will be assembled by the GNU assembler and finally linked by the GNU linker.
On windows, this is acheived through the mingw toolchain.

#### Asm Printer
Currently, there is no structured assembly printer. Assembly code is generated by rawdogging.
#### (No) Instruction Seletion 
There is minimal instruction selection: each CIR already closely resembles a machine instruction. For each platform, an instruction is simply selected with an 1-1 mapping.
#### Register Allocation
All variables and arguments are allocated on the stack. Registers are allocated with a simple linear-greedy algorithm. 
Within each function, the `Register Manager` keep tracks of the register being used, and which `Result Location` uses it. 
A register is allocated upon request. When a register needs to repurpose (e.g. passing arguments to a function), we free up the register by moving its content to a open register. When we run out of registers, we spill a register on the stack.

