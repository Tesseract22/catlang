# Rework Code Generation

## Stack Allocation

Currently, the code is generated by a two time traversal of the CIRs, directly outputing to the files. This turns out to be a HUGE pain in the ass.
For the first time, we count how many bytes should be allocated on the stack frame. For the second time, we actually generates the code. However,

1) For the second traversal, for each allocation on the stack (temporary array, certain kinds of argument passing and return value of functions, etc.), we have to remember to keep track of the current stack pointer, and alings it properly.

2) Making keep track of things on the stack top very tricky and error-prone.


We should instead use the following strategy: Do only one traversal, but instead of writing directly into a file, output it into a buffer. This buffer does not include the `prologue` of the function.
As we traverse the CIR, calculate the spilling. Only after the entire CIR is traversed, then the `prologue` is created. Outside of the `prologue`, there should be **NO STACK ALLOCATION**, except:

1) Pushing argument onto the stack before calls

2) Shadow space for window's fastcall calling convention

Alongside with solving the aformentioned problems, this also make it possible to avoid pre-allocating space for all non-volitile (callee saved) registers, instead of allocate as needed.
